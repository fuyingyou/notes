## Java中的锁

- 乐观锁、悲观锁
- 自旋锁、适应性自旋锁
- 无锁、偏向锁、轻量级锁、重量级锁
- 公平锁、非公平锁
- 可重入锁、非可重入锁
- 独享锁（排他锁）、共享锁

> synchronized关键字和Lock的实现类都是悲观锁



**悲观锁**： 认为在使用数据的时候，一定会有别的线程来修改数据，因此在获取数据的时候先加锁，确保数据不会被其他的线程修改。`适合写操作多的场景`，先加锁可以保证写操作时的数据正确。

**乐观锁**：认为不会有其他的线程修改数据，不会添加锁。但会在更新数据的时候去判断有没有别的线程更新了数据（具体方法可以使用版本号机制或 CAS 算法）。` 适合读操作多的场景`，不加锁可以使读的操作性能大幅提升。

**自旋锁**： 挂起线程和恢复线程的操作都需要转入内核态中完成，这些操作对系统的并发性能带来了很大的压力。自旋可以使线程不必阻塞直接获取同步资源，避免切换线程的开销。

- 应用场景：同步资源的锁定时间很短，为了一点时间去切换线程、线程挂起和恢复现场的花费可能会让系统得不偿失，所以在物理机器有多个处理器的时候，可以选择使得线程不放弃CPU，看持有锁的线程是否很快就会释放锁。
- 缺点：虽然避免了线程切换的开销，但要占用处理器的时间。**如果锁被占用的时间很短，那么自旋锁的效果会非常好。但如果锁被占用的时间很长，那么自旋的线程会白白浪费处理器的资源。**所以自旋等待的时间会有一定的限度。如果自旋超过限定次数（**默认十次**）还没有成功获得锁，线程就应该被挂起。

**自适应自旋锁**： 自旋的时间不再固定，由上一次在同一个锁上的自旋时间和锁的拥有者的状态来决定。如果某个锁对象自旋等待成功获取过锁，并且持有锁的线程正在运行，那么JVM会认为该锁自旋获取到锁的可能性更大，会自动增加等待时间（自旋次数）。如果某个线程自旋很少获得锁，那么以后可能就会直接挂起，省略掉自旋的过程，避免浪费处理器资源。自适应自旋会使JVM对程序的锁的状态预测越来越准确。

**公平锁**：多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，只有队列中的第一个线程才能获得锁。

- 优点：等待锁的线程不会饿死。
- 缺点：整体的吞吐效率相对于非公平锁要低，等待队列中除了第一个线程以外的所有线程都会阻塞，CPU唤醒阻塞线程的总开销比非公平锁大。

**非公平锁**： 线程直接尝试获得锁，获取不到后才进入等待队列的队尾等待。（即如果此时锁刚好可用，那么这个线程就可以无需阻塞的直接获取到锁）会出现后申请锁的线程先获取锁的场景。

- 优点：减少唤起线程的开销，整体的吞吐效率高。（因为线程有概率直接获得锁，所以CPU不需要每次都唤醒线程）

- 缺点：处于等待队列中的线程可能会饿死，或者等很久才会获得锁。

**可重入锁**：在同一个线程在外层方法已经获得锁的时候，再进入该线程的内部方法会**自动获取锁**，前提是锁对象是同一个对象或class，不会因为之前获取过锁但还没释放而阻塞。ReentrantLock和synchronized都是可重入锁。

- 优点：一定程度上避免死锁

**非可重入锁**： 不允许同一个线程多次获取同一个锁

**独享锁（排他锁）**：该锁一次只能被一个线程所持有。如果某线程对数据加上排他锁后，其它线程不能再对数据加任何类型的锁。`获得排他锁的线程既能读数据又能修改数据`。synchronize和Lock的实现类就是独享锁。

**共享锁**：该锁可被多个线程所持有。如果某线程对数据加上共享锁之后，那么其它线程只能再对其加共享锁，不能加排他锁。`获得共享锁的线程只能读数据，不能修改数据`。（读完了才可以加排他锁去写）

> 在ReentrantReadWriteLock里面，读锁和写锁的加锁的方式不一样，读锁是共享锁，写锁是独享锁。因为读写锁分离，所以ReentrantReadWriteLock的并发性相比一般的互斥锁有很大的提升。

**偏向锁**：是为了在无锁竞争的情况下，避免在重复的获取锁和释放锁过程中执行不必要的CAS原子指令，因为CAS原子指令虽然相对于重量级锁来说开销比较小但还是存在一定程度的本地延迟。

​	偏向锁使用了一种等待竞争出现才会释放锁的机制。所以当其他线程尝试获取偏向锁时，持有偏向锁的线程才会释放锁。但是偏向锁的撤销需要等到全局安全点(就是当前线程没有正在执行的字节码)。它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着。如果线程不处于活动状态，直接将对象头设置为无锁状态。如果线程活着，JVM会遍历栈帧中的锁记录，栈帧中的锁记录和对象头要么偏向于其他线程，要么恢复到无锁状态或者标记对象不适合作为偏向锁。

锁膨胀方向： 无锁 → 偏向锁 → 轻量级锁 → 重量级锁 (此过程是不可逆的)