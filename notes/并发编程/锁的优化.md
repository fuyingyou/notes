### 锁的优化

`锁粗化`：就是减少不必要的紧连在一起的unlock，lock操作，将多个连续的锁扩展成一个范围更大的锁。

`锁消除`：JVM会判断在一段程序中的同步明显不会逃逸出去从而被其他线程访问到，那JVM就把它们当作栈上数据对待，认为这些数据是线程独有的，不需要加同步。此时就会进行锁消除。通过逃逸分析也可以在线程本的Stack上进行对象空间的分配(同时还可以减少Heap上的垃圾收集开销)。

`轻量级锁`：这种锁实现的背后基于这样一种假设，即：在真实的情况下我们程序中的大部分同步代码一般都处于无锁竞争状态(即单线程执行环境)，在无锁竞争的情况下完全可以避免调用操作系统层面的重量级互斥锁，取而代之的是在monitorenter和monitorexit中只需要依靠一条CAS原子指令就可以完成锁的获取及释放。当存在锁竞争的情况下，执行CAS指令失败的线程将调用操作系统互斥锁进入到阻塞状态，当锁被释放的时候被唤醒 （执行CAS指令成功的线程执行完后，释放锁 唤醒被阻塞的线程）。

`偏向锁`：是为了在无锁竞争的情况下，避免在重复的获取锁和释放锁过程中执行不必要的CAS原子指令，因为CAS原子指令虽然相对于重量级锁来说开销比较小但还是存在一定程度上的本地延迟。

​	偏向锁使用了一种等待竞争出现才会释放锁的机制。所以当其他线程尝试获取偏向锁时，持有偏向锁的线程才会释放锁。但是偏向锁的撤销需要等到全局安全点(就是当前线程没有正在执行的字节码)。它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着。如果线程不处于活动状态，直接将对象头设置为无锁状态。如果线程活着，JVM会遍历栈帧中的锁记录，栈帧中的锁记录和对象头要么偏向于其他线程，要么恢复到无锁状态或者标记对象不适合作为偏向锁。

`适应性自旋`：当线程在获取轻量级锁的过程中执行CAS操作失败时，在进入重量级锁前，会进入忙等待然后再次尝试，当尝试一定的次数后如果仍然没有成功则调用互斥锁进入到阻塞状态。

> 总结：
>
> - 偏向锁通过对比Mark Word解决加锁问题，避免执行CAS操作。
> - 轻量级锁是通过用CAS操作和自旋来解决加锁问题，避免线程阻塞和唤醒而影响性能。
> - 重量级锁是将除了拥有锁的线程以外的线程都阻塞。

### 锁的优缺点对比

| 锁       |                             优点                             |                             缺点                             |              使用场景              |
| -------- | :----------------------------------------------------------: | :----------------------------------------------------------: | :--------------------------------: |
| 偏向锁   | 加锁和解锁不需要CAS操作，没有额外的性能消耗，和执行非同步方法相比仅存在纳秒级的差距 |        如果线程间存在锁竞争，会带来额外的锁撤销的消耗        | 适用于只有一个线程访问同步块的场景 |
| 轻量级锁 |              竞争的线程不会阻塞，提高了响应速度              |          始终得不到锁的线程，使用自旋会消耗CPU性能           | 追求响应时间，同步块执行速度非常快 |
| 重量级锁 |               线程竞争不适用自旋，不会消耗CPU                | 线程阻塞，响应时间缓慢，在多线程下，频繁的获取释放锁，会带来巨大的性能消耗 |   追求吞吐量，同步块执行时间较长   |
