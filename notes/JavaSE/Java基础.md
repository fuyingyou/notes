Java 学习



Java8新特性

哈希表默认大小：16

hash碰撞：生成链表，后来的作为链表头，之前的后移。

HashMap提供加载因子：默认0.75->当元素到达现有hash表的75%时进行扩容。扩容后链表中的每个元素重新进行哈希运算，置入新地址中。

变红黑树：某一个碰撞个数大于8，与此同时，总容量大于64，会将链表转换为红黑树

好处：除了添加以外的操作效率都比链表高。扩容以后重排序不需要哈希算法就可以重新运算出新的位置：原来哈希表的总长度+当前所在的位置



ConcurrentHashMap：

7并发级别（ConcurrentLevel）默认：16

8 CAS（无锁）算法 ： 链表+红黑树，效率提高了

方法区属于堆中永久区（PremGen）的一部分

永久区几乎不会垃圾回收机制回收（回收条件比较苛刻）



###  Date 2021.11.30

1. 可变参数类型：参数写为：类型...参数名  例： String...strs
2. getClass()  得到 class[ I  ,[ 表示数组，I表示int类型
3. 使用可变参数列表，不依赖自动包装机制，而是使用基本类型，应尽量避免使用可变参数列表。
4. 初始化在Java中有至关重要的地位。
5. 一个编译单元，即.java文件，只能有一个public类，那么包之外是看不见.java文件中的其他类的。
6. Java包的命名规则全部使用小写字母。
7. package和import是将单一的全局命名空间分隔开，使得无论多少人使用和编写类，都不会出现命名冲突。

### Date 2021.12.01

1. classpath可以包含多个可供选择的查询路径，通过分号隔开。在使用jar文件时，必须在类路径中把jar文件实际名称写清楚。

2. 如果导入的类库有重复部分，只要不写这些重复的就没问题。

3. 可以不import，直接使用

   ````java
   java.util.Vector v = new java.util.Vector();
   ````

4. 定制工具库： classpath设置搜索路径（将工具库的路径放进去），其他类使用工具库时，导入工具库所在的包。

5. 无权限修饰符  == 包访问权限

6. 继承而来的类可以访问public、protected 。 （extends：继承）

7. 类不可以设置为private、protected。(内部类除外)

### Date 2021.12.02

1. Java会自动在导出类的构造器中插入对基类的构造器。（且在导出构造器的最前面）（super：超类）
2. 编译器强制初始化基类，但不监督将成员对象初始化。
3. 确保正确清理：finally 。以防异常出现。
4. 清理动作同生成顺序相反，通常这就要求基类元素仍然存在。
5. 垃圾回收器可能永远也不会被调用，且就算被调用，顺序也不一定。
6. @override 的存在可以防止程序员意外重载。
7. is a 继承；has a 组合。
8. finally修饰对象，使引用指向不变，即不能重新指向其他对象，但对象自身可以修改。
9. Java不提供使任何对象恒定不变的途径（但是可以自己编写实现）。数组也是对象。
10. 带有恒定初始值的final static基本类型全用大写字母命名。
11. static的属性在装载时被初始化，不是每次创建新对象都初始化。
12. Java允许生成“空白final”。（指声明为final，但是又没有给定初值的域）必须在域的定义处或者每个构造器中用表达式对final进行赋值，这就是final域在使用前总是被初始化的原因所在。
13.  final参数：可以将参数声明为final，无法在方法内部更改参数引用所指向的对象。主要用来向匿名内部类传递数据。
14. final方法。使用final方法的两个原因
    1. 把方法锁定，以防止任何继承类修改它的含义。
    2. 效率。转为内嵌调用。方法调用机制：将参数压入栈，跳至方法代码外并执行，然后跳回并清理栈中的参数，处理返回值。如果一个方法很大，那么可能看不到内嵌带来的任何性能提高（程序代码膨胀），甚至效率可能反而降低。在最近的版本中效率问题交给编译器和JVM去处理，只有在想要明确禁止覆盖时，才会将方法设置为final的。
15. 一般来说，类的代码在初次使用时才加载。这里指的是加载发生于创建类的第一个对象时，但是当访问static域或static方法时，也会发生加载。
16. 所有的static对象和static代码段都会在加载时依程序中的顺序（定义类时的书写顺序）而依次初始化。
17. 对象被创建时，所有的基本类型都会被设置成默认值，对象引用被设为null，这是通过将对象内存设为二进制零值而一举生成的，然后再调用构造器将成员初始化。



- **parseInt(String s):** 返回用十进制参数表示的整数值。
- **parseInt(int i):** 使用指定基数的字符串参数表示的整数 (基数可以是 10, 2, 8, 或 16 等进制数) 。

### Date 2022.10.10

`trim()` 方法用于删除字符串的头尾空白符。

1、`int indexOf(String str)` ：返回第一次出现的指定子字符串在此字符串中的索引。
2、`int indexOf(String str, int startIndex)`：从指定的索引处开始，返回第一次出现的指定子字符串在此字符串中的索引。
3、`int lastIndexOf(String str)` ：返回在此字符串中最右边出现的指定子字符串的索引。
4、`int lastIndexOf(String str, int startIndex)` ：从指定的索引处开始向后搜索，返回在此字符串中最后一次出现的指定子字符串的索引。

```java
Collectors.toMap(Info::getName, Info::getContent, (a, b) -> b)
```

第三个参数用在key值冲突的情况下：如果新元素产生的key在Map中已经出现过了，第三个参数就会定义解决的办法。

### Date 2022.10.30

@Schedule
cron表达式语法

[秒] [分] [小时] [日] [月] [周] [年]

特殊符号：

> '*'：任意值，可以解为‘每’   每天/每月
>
> '/' ：增量     例如 0/1 表示从第0分钟开始，每隔1分钟
>
> 'L'  :   表示最后，只能出现在DayofWeek和DayofMonth域，如果在DayofWeek域使用5L,意味着在最后的一个星期四触发

设置定时任务为每天凌晨2点执行和每小时执行一次
每天凌晨2点 0 0 2 * * ?和每天隔一小时 0 * */1 * * ?

例1：每隔5秒执行一次：*/5 * * * * ?

例2：每隔5分执行一次：0 */5 * * * ?

在26分、29分、33分执行一次：0 26,29,33 * * * ?

例3：每天半夜12点30分执行一次：0 30 0 * * ? （注意日期域为0不是24）

每天凌晨1点执行一次：0 0 1 * * ?

每天上午10：15执行一次： 0 15 10 ? * * 或 0 15 10 * * ? 或 0 15 10 * * ? *

每天中午十二点执行一次：0 0 12 * * ?

每天14点到14：59分，每1分钟执行一次：0 * 14 * * ?

每天14点到14：05分，每1分钟执行一次：0 0-5 14 * * ?

每天14点到14：55分，每5分钟执行一次：0 0/5 14 * * ?

每天14点到14：55分，和18点到18点55分，每5分钟执行一次：0 0/5 14,18 * * ?

每天18点执行一次：0 0 **18** * * ?

每天18点、22点执行一次：0 0 **18,22** * * ?

每天7点到23点，每整点执行一次：0 0 **7-23** * * ?

每个整点执行一次：0 0 **0/1** * * ?



### Date 2022.10.31

1. 父pom和子pom关系（继承）

   1. 如果父pom中是```<dependencies></dependencies>```时，那么子pom会自动继承父pom依赖，不需要子pom去导入

   2. 如果父pom中是

      ```xml
      <dependencyManagement>
      	<dependencies>....</dependencies>
      </dependencyManagement>
      ```

      则子pom不会自动继承父pom的依赖，除非子pom中声明。声明需要groupId和artifactId，无需给到version。一句话总结：第二种方法是用来约束子pom，若要使用，需声明。

2. 自定义配置怎么出现提示

   ```xml
   <!--注解执行器-->
   <dependency>
       <groupId>org.springframework.boot</groupId>
       <artifactId>spring-boot-configuration-processor</artifactId>
       <optional>true</optional>
   </dependency>
   ```


3. Java中Date类的toInstant()方法用于将Date对象转换为Instant对象。在转换过程中会创建一个Instant，用于表示时间轴上与此日期相同的点。

   ```Java
   Original Date: Fri Jul 12 06:01:49 UTC 1996
   Instant: 1996-07-12T06:01:49.766Z
   ```







### Date 2022.11.15

**布隆过滤器**：

本质：一个空的2进制数组（数据全为0、1，初始全0）

- 插入：一个key，经过k个hash函数运算后，得到k个值，将2进制数组对应下标的位置置为1。

- 查询：将key同样进行k个hash，去2进制数组比对对应下标位置的值，全为1则可能存在该key，不全为1，则一定不存在该key

- 删除：不能删

- 误判率：误以为存在的概率

优点：

- 不需要存储元素本身，节省空间的同时保证了数据安全。
- 查询速度很快。理解为O(k), k为哈希函数的个数。

缺点：

- 有一定的误判率，不适合对误判率要求较高的场景
- 无法删除数据

应用：

- 大集合中检查元素是否重复

- Redis中防止缓存穿透

  > 缓存穿透：key对应的数据在数据源并不存在，每次针对此key的请求从缓存获取不到，请求都会到数据源，从而可能压垮数据源。
  >
  > 解决办法：将数据源的key是否存在的信息存储到布隆过滤器中，如果布隆过滤器判定数据不存在，则不再请求数据源。



**布隆计数过滤器**：待学

**布谷鸟过滤器**：

​      初始化一个给定容量的过滤器Filter，这个容量数为2的n次方，如果不为2的n次方，内部会通将其转化为2的n次方。

- 插入：

  先进行一次hash，得出应当插入位置和应当插入的值。

  如果这个这个位置（bucket内的4个位置均被占用）插入失败，会进行第二次hash(或者利用指纹和第一个hash位置异或？前提是确保指纹hash(fp)!=0)，查看第二个位置能否插入。

  若第二个位置插入失败，则会随机在两个位置挑选一个将其中的一个值标记为旧值，用新值覆盖旧值，旧值会在重复上面的步骤进行插入。

  会对插入的值进行校验，只有当未插入过该值时才会插入成功，若过滤器中已经存在该值，会插入失败返回false。

- 扩容：  如果数组过小，会发生循环挤兑的情况，如果超过最大挤兑次数，进行扩容，重新计算每个指纹的位置。

- 查找：用两个hash函数计算，将计算结果与两个元素中的8个位置的指纹进行对比，如果对比成功则表示数据存在。先进行一次hash查询数据，若没有该值会进行第二次hash进行查询，若还是没有会返回false。

- 删除

  - 通过两次hash找到索引位置，若有该数据，将该位置数据删除。因为每个对象的指纹会存储到一个位置中，所以可以通过删除这个指纹来删除数据。

  - 删除功能无法使用的情况：如果相同对象存储超过8个，就无法使用删除功能 `？？(TODO) 为什么？？`；如果俩数据的哈希值和指纹相同时，会出现误删除情况。

- 删除全部：布谷鸟过滤器可以删除全部元素（重置数组为0）。

- 更新：删除后再添加新指纹。

优点：

- 支持删除
- 更节省空间（比布隆过滤器节省约40%），在错误率小于3%时，空间性能优于布隆过滤器
- 查询效率高（最低只需一次哈希，第二个位置可以根据第一个位置和指纹异或求得？`? ?`）

缺点： 

- 插入性能差
  - 布谷鸟过滤器在计算哈希后可能当前位置上已经存储了指纹，这时就要将已存储的项踢到候选桶，随着桶越来越满，产生冲突的可能性越来越大，插入耗时越来越高。
  - 布隆过滤器插入时计算好哈希直接写入位即可
- 插入重复元素存在上限
  - 布谷鸟过滤器对已存在的值会做踢出操作，因此重复元素的插入存在上限。
  - 布隆过滤器在插入重复元素时并没有影响，只是对已存在的位再置一遍。
- 空间大小必须是2的指数（布隆过滤器不需要2的指数）
- 删除有问题：
  - 删除仅在相同哈希值被插入一次时是完美的
  - 如果元素没有插入便进行删除，可能会出现误删除，这和假阳性率的原因相同
  - 如果元素插入了多次，那么每次删除仅会删除一个值，你需要知道元素插入了多少次才能删除干净，或者循环运行删除直到删除失败为止

Arrays.sort(nums, (a, b) -> b[1] - a[1]);    返回值大于0



##  序列化

> 所有需要网络传输的对象，都需要实现序列化接口，通常所有的JavaBean都实现Serializable接口。

> 对象的类名、实例变量（包括基本类型、数组、对其他对象的引用）都会被序列化；方法、静态变量（又称类变量）、transient修饰的变量都不会被实例化
>
> // 对象的类型需要被序列化的原因是反序列化时需要对象的class文件?
>
> transient 修饰 不想被序列化的属性

> 序列化对象的引用类型成员变量必须是可序列化的。
>
> 在通过文件、网络来读取序列化后的对象时，必须按照实际写入的顺序读取。
>
> // 是否有某种读取方式是可以不按照实际写入的顺序读取？

> 单例类序列化时需要重写readResolve()方法，否则会破坏单例原则
>
> 同一对象序列化多次，只有第一次序列化为二进制流，以后都只会保存序列化编号，不会重复序列化。
>
> 建议所有可序列化的类加上serialVersionUID版本号，方便后期项目升级。
>
> // 如果单体应用是否需要版本号？
>
> // 如果非单体应用未添加版本号，重启应用是否可以解决问题



> 

